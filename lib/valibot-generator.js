"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateValibot = generateValibot;
const node_fs_1 = require("node:fs");
const node_path_1 = __importDefault(require("node:path"));
const logger_1 = __importDefault(require("./utils/logger"));
const removeDir_1 = __importDefault(require("./utils/removeDir"));
// Minimal Valibot generator per MVP PRD
function isScalarOrEnum(field) {
    return field.kind === "scalar" || field.kind === "enum";
}
function getUsedEnumNames(model) {
    return Array.from(new Set(model.fields.filter((f) => f.kind === "enum").map((f) => String(f.type))));
}
const SCALAR_TO_V = {
    String: "v.string()",
    Int: "v.number()",
    Float: "v.number()",
    Decimal: "v.number()",
    Boolean: "v.boolean()",
    DateTime: "v.date()",
    Json: "v.any()",
    BigInt: "v.bigint()",
    Bytes: "v.instance(Uint8Array)",
};
function mapScalar(type) {
    var _a;
    return (_a = SCALAR_TO_V[type]) !== null && _a !== void 0 ? _a : "v.any()";
}
function mapFieldToValibot(field, enums) {
    // Relations and unsupported are handled by callers (filtered out), but keep a safe fallback
    if (field.kind === "object" || field.kind === "unsupported") {
        return "v.any()";
    }
    let base;
    const type = String(field.type);
    if (field.kind === "enum") {
        const enumDef = enums.find((e) => e.name === type);
        if (enumDef) {
            const constName = `${type}Enum`;
            base = constName;
        }
        else {
            base = "v.any()";
        }
    }
    else {
        base = mapScalar(type);
    }
    if (field.isList) {
        base = `v.array(${base})`;
    }
    return base;
}
function modelFilename(modelName) {
    return `${modelName}.schema.ts`;
}
function buildObjectSchema(name, fields, enums, makeField) {
    const entries = fields
        .filter(isScalarOrEnum)
        .map((f) => `  ${f.name}: ${makeField(f)}`);
    return [
        `export const ${name} = v.object({`,
        entries.join(",\n"),
        "});",
        `export type ${name}Type = v.InferOutput<typeof ${name}>;`,
        "",
    ];
}
function buildSchemasForModel(model, enums) {
    const lines = [];
    lines.push("// Generated by prisma-valibot-generator — Do not edit manually");
    lines.push("import * as v from 'valibot';");
    // Import enum schemas if this model uses any
    const usedEnumNames = getUsedEnumNames(model);
    if (usedEnumNames.length > 0) {
        const importNames = usedEnumNames.map((name) => `${name}Enum`).join(", ");
        lines.push(`import { ${importNames} } from './enums';`);
    }
    lines.push("");
    // Full model (all fields required)
    lines.push(...buildObjectSchema(`${model.name}Schema`, model.fields, enums, (f) => mapFieldToValibot(f, enums)));
    // Create validator (required fields only — heuristic: required w/o default/id/updatedAt)
    const createFields = model.fields.filter((f) => isScalarOrEnum(f) &&
        f.isRequired &&
        !f.hasDefaultValue &&
        !f.isId &&
        !f.isUpdatedAt);
    lines.push(...buildObjectSchema(`Create${model.name}Schema`, createFields, enums, (f) => mapFieldToValibot(f, enums)));
    // Update validator (all fields optional)
    lines.push(...buildObjectSchema(`Update${model.name}Schema`, model.fields, enums, (f) => `v.optional(${mapFieldToValibot(f, enums)})`));
    return lines.join("\n");
}
function buildEnumsFile(enums, enumValueMode) {
    const pickValue = (val) => {
        var _a;
        if (enumValueMode === "dbName") {
            return (_a = val.dbName) !== null && _a !== void 0 ? _a : val.name;
        }
        return val.name;
    };
    const lines = [];
    lines.push("// Generated by prisma-valibot-generator — Do not edit manually");
    lines.push("import * as v from 'valibot';");
    lines.push("");
    for (const enm of enums) {
        const valuesList = enm.values
            .map((val) => `'${pickValue(val)}'`)
            .join(", ");
        const valuesConst = `${enm.name}Values`;
        const constName = `${enm.name}Enum`;
        lines.push(`export const ${valuesConst} = [${valuesList}] as const;`);
        lines.push(`export type ${enm.name}Value = typeof ${valuesConst}[number];`);
        lines.push(`export const ${constName} = v.picklist(${valuesConst});`);
        lines.push(`export type ${enm.name}EnumType = v.InferOutput<typeof ${constName}>;`);
        lines.push("");
    }
    return lines.join("\n");
}
async function generateValibot(options) {
    var _a, _b, _c;
    logger_1.default.debug("[prisma-valibot] Starting generation");
    const schemaDir = node_path_1.default.dirname(options.schemaPath);
    const explicitOutput = (_a = options.generator.output) === null || _a === void 0 ? void 0 : _a.value;
    const defaultOutput = node_path_1.default.join(process.cwd(), "node_modules", ".prisma-valibot");
    const outDir = explicitOutput
        ? node_path_1.default.isAbsolute(explicitOutput)
            ? explicitOutput
            : node_path_1.default.join(schemaDir, explicitOutput)
        : defaultOutput;
    const generatedDir = outDir;
    logger_1.default.debug("[prisma-valibot] Output directory resolved to:", generatedDir);
    await node_fs_1.promises.mkdir(generatedDir, { recursive: true });
    await (0, removeDir_1.default)(generatedDir, true);
    logger_1.default.debug("[prisma-valibot] Output directory cleaned");
    const models = options.dmmf.datamodel.models;
    const enums = (_b = options.dmmf.datamodel.enums) !== null && _b !== void 0 ? _b : [];
    const enumValueMode = (((_c = options.generator.config) === null || _c === void 0 ? void 0 : _c.enumValue) === "dbName" ? "dbName" : "name");
    // Generate per-model files
    logger_1.default.debug("[prisma-valibot] Generating schemas for models:", models.map((m) => m.name));
    for (const model of models) {
        const content = buildSchemasForModel(model, enums);
        const filePath = node_path_1.default.join(generatedDir, modelFilename(model.name));
        await node_fs_1.promises.writeFile(filePath, content, "utf8");
        logger_1.default.debug(`[prisma-valibot] Wrote schema for model ${model.name} -> ${filePath}`);
    }
    // Generate enums file
    if (enums.length > 0) {
        const enumsContent = buildEnumsFile(enums, enumValueMode);
        await node_fs_1.promises.writeFile(node_path_1.default.join(generatedDir, "enums.ts"), enumsContent, "utf8");
        logger_1.default.debug("[prisma-valibot] Wrote enums file");
    }
    // Index barrel
    const indexLines = [];
    for (const model of models) {
        const fileBase = `./${modelFilename(model.name)}`;
        indexLines.push(`export * from '${fileBase.replace(/\\.ts$/, "")}';`);
    }
    if (enums.length > 0) {
        indexLines.push("export * from './enums';");
    }
    await node_fs_1.promises.writeFile(node_path_1.default.join(generatedDir, "index.ts"), `${indexLines.join("\n")}\n`, "utf8");
    logger_1.default.debug("[prisma-valibot] Wrote index barrel");
    logger_1.default.info("Prisma Valibot: generation complete");
}
//# sourceMappingURL=valibot-generator.js.map