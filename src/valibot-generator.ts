import { promises as fs } from "node:fs";
import path from "node:path";
import type { DMMF, GeneratorOptions } from "@prisma/generator-helper";
import logger from "./utils/logger";
import removeDir from "./utils/removeDir";

// Minimal Valibot generator per MVP PRD

function isScalarOrEnum(field: DMMF.Field): boolean {
	return field.kind === "scalar" || field.kind === "enum";
}

function getUsedEnumNames(model: DMMF.Model): string[] {
	return Array.from(
		new Set(
			model.fields.filter((f) => f.kind === "enum").map((f) => String(f.type)),
		),
	);
}

const SCALAR_TO_V: Record<string, string> = {
	String: "v.string()",
	Int: "v.number()",
	Float: "v.number()",
	Decimal: "v.number()",
	Boolean: "v.boolean()",
	DateTime: "v.date()",
	Json: "v.any()",
	BigInt: "v.bigint()",
	Bytes: "v.instance(Uint8Array)",
};

function mapScalar(type: string): string {
	return SCALAR_TO_V[type] ?? "v.any()";
}

function mapFieldToValibot(
	field: DMMF.Field,
	enums: ReadonlyArray<DMMF.DatamodelEnum>,
): string {
	// Relations and unsupported are handled by callers (filtered out), but keep a safe fallback
	if (field.kind === "object" || field.kind === "unsupported") {
		return "v.any()";
	}

	let base: string;
	const type = String(field.type);

	if (field.kind === "enum") {
		const enumDef = enums.find((e) => e.name === type);
		if (enumDef) {
			const constName = `${type}Enum`;
			base = constName;
		} else {
			base = "v.any()";
		}
	} else {
		base = mapScalar(type);
	}

	if (field.isList) {
		base = `v.array(${base})`;
	}

	return base;
}

function modelFilename(modelName: string) {
	return `${modelName}.schema.ts`;
}

function buildObjectSchema(
	name: string,
	fields: ReadonlyArray<DMMF.Field>,
	enums: ReadonlyArray<DMMF.DatamodelEnum>,
	makeField: (f: DMMF.Field) => string,
): string[] {
	const entries = fields
		.filter(isScalarOrEnum)
		.map((f) => `  ${f.name}: ${makeField(f)}`);
	return [
		`export const ${name} = v.object({`,
		entries.join(",\n"),
		"});",
		`export type ${name}Type = v.InferOutput<typeof ${name}>;`,
		"",
	];
}

function buildSchemasForModel(
	model: DMMF.Model,
	enums: ReadonlyArray<DMMF.DatamodelEnum>,
): string {
	const lines: string[] = [];
	lines.push("// Generated by prisma-valibot-generator — Do not edit manually");
	lines.push("import * as v from 'valibot';");
	// Import enum schemas if this model uses any
	const usedEnumNames = getUsedEnumNames(model);
	if (usedEnumNames.length > 0) {
		const importNames = usedEnumNames.map((name) => `${name}Enum`).join(", ");
		lines.push(`import { ${importNames} } from './enums';`);
	}
	lines.push("");

	// Full model (all fields required)
	lines.push(
		...buildObjectSchema(`${model.name}Schema`, model.fields, enums, (f) =>
			mapFieldToValibot(f, enums),
		),
	);

	// Create validator (required fields only — heuristic: required w/o default/id/updatedAt)
	const createFields = model.fields.filter(
		(f) =>
			isScalarOrEnum(f) &&
			f.isRequired &&
			!f.hasDefaultValue &&
			!f.isId &&
			!f.isUpdatedAt,
	);
	lines.push(
		...buildObjectSchema(
			`Create${model.name}Schema`,
			createFields,
			enums,
			(f) => mapFieldToValibot(f, enums),
		),
	);

	// Update validator (all fields optional)
	lines.push(
		...buildObjectSchema(
			`Update${model.name}Schema`,
			model.fields,
			enums,
			(f) => `v.optional(${mapFieldToValibot(f, enums)})`,
		),
	);

	return lines.join("\n");
}

function buildEnumsFile(
	enums: ReadonlyArray<DMMF.DatamodelEnum>,
	enumValueMode: "name" | "dbName",
): string {
	type EnumValueShape = { name: string; dbName?: string | null };
	const pickValue = (val: EnumValueShape): string => {
		if (enumValueMode === "dbName") {
			return val.dbName ?? val.name;
		}
		return val.name;
	};
	const lines: string[] = [];
	lines.push("// Generated by prisma-valibot-generator — Do not edit manually");
	lines.push("import * as v from 'valibot';");
	lines.push("");
	for (const enm of enums) {
		const valuesList = enm.values
			.map((val) => `'${pickValue(val as unknown as EnumValueShape)}'`)
			.join(", ");
		const valuesConst = `${enm.name}Values`;
		const constName = `${enm.name}Enum`;
		lines.push(`export const ${valuesConst} = [${valuesList}] as const;`);
		lines.push(`export type ${enm.name}Value = typeof ${valuesConst}[number];`);
		lines.push(`export const ${constName} = v.picklist(${valuesConst});`);
		lines.push(
			`export type ${enm.name}EnumType = v.InferOutput<typeof ${constName}>;`,
		);
		lines.push("");
	}
	return lines.join("\n");
}

export async function generateValibot(options: GeneratorOptions) {
	logger.debug("[prisma-valibot] Starting generation");
	const schemaDir = path.dirname(options.schemaPath);
	const explicitOutput = options.generator.output?.value;
	const defaultOutput = path.join(
		process.cwd(),
		"node_modules",
		".prisma-valibot",
	);
	const outDir = explicitOutput
		? path.isAbsolute(explicitOutput)
			? explicitOutput
			: path.join(schemaDir, explicitOutput)
		: defaultOutput;

	const generatedDir = outDir;
	logger.debug("[prisma-valibot] Output directory resolved to:", generatedDir);
	await fs.mkdir(generatedDir, { recursive: true });
	await removeDir(generatedDir, true);
	logger.debug("[prisma-valibot] Output directory cleaned");

	const models = options.dmmf.datamodel.models;
	const enums = options.dmmf.datamodel.enums ?? [];
	const enumValueMode = (
		options.generator.config?.enumValue === "dbName" ? "dbName" : "name"
	) as "name" | "dbName";

	// Generate per-model files
	logger.debug(
		"[prisma-valibot] Generating schemas for models:",
		models.map((m) => m.name),
	);
	for (const model of models) {
		const content = buildSchemasForModel(model, enums);
		const filePath = path.join(generatedDir, modelFilename(model.name));
		await fs.writeFile(filePath, content, "utf8");
		logger.debug(
			`[prisma-valibot] Wrote schema for model ${model.name} -> ${filePath}`,
		);
	}

	// Generate enums file
	if (enums.length > 0) {
		const enumsContent = buildEnumsFile(enums, enumValueMode);
		await fs.writeFile(
			path.join(generatedDir, "enums.ts"),
			enumsContent,
			"utf8",
		);
		logger.debug("[prisma-valibot] Wrote enums file");
	}

	// Index barrel
	const indexLines: string[] = [];
	for (const model of models) {
		const fileBase = `./${modelFilename(model.name)}`;
		indexLines.push(`export * from '${fileBase.replace(/\\.ts$/, "")}';`);
	}
	if (enums.length > 0) {
		indexLines.push("export * from './enums';");
	}
	await fs.writeFile(
		path.join(generatedDir, "index.ts"),
		`${indexLines.join("\n")}\n`,
		"utf8",
	);
	logger.debug("[prisma-valibot] Wrote index barrel");
	logger.info("Prisma Valibot: generation complete");
}
