"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateValibot = generateValibot;
const node_fs_1 = require("node:fs");
const node_path_1 = __importDefault(require("node:path"));
const logger_1 = __importDefault(require("./utils/logger"));
const removeDir_1 = __importDefault(require("./utils/removeDir"));
// Minimal Valibot generator per MVP PRD
function isScalarOrEnum(field) {
    return field.kind === "scalar" || field.kind === "enum";
}
function getUsedEnumNames(model) {
    return Array.from(new Set(model.fields.filter((f) => f.kind === "enum").map((f) => String(f.type))));
}
const SCALAR_TO_V = {
    String: "v.string()",
    Int: "v.number()",
    Float: "v.number()",
    Decimal: "v.number()",
    Boolean: "v.boolean()",
    DateTime: "v.date()",
    Json: "v.any()",
    BigInt: "v.bigint()",
    Bytes: "v.instance(Uint8Array)",
};
function mapScalar(type) {
    var _a;
    return (_a = SCALAR_TO_V[type]) !== null && _a !== void 0 ? _a : "v.any()";
}
function mapFieldToValibot(field, enums) {
    // Relations and unsupported are handled by callers (filtered out), but keep a safe fallback
    if (field.kind === "object" || field.kind === "unsupported") {
        return "v.any()";
    }
    let base;
    const type = String(field.type);
    if (field.kind === "enum") {
        const enumDef = enums.find((e) => e.name === type);
        if (enumDef) {
            const constName = `${type}Picklist`;
            base = constName;
        }
        else {
            base = "v.any()";
        }
    }
    else {
        base = mapScalar(type);
    }
    if (field.isList) {
        base = `v.array(${base})`;
    }
    return base;
}
function modelFilename(modelName) {
    return `${modelName}.schema.ts`;
}
function buildObjectSchema(name, fields, makeField) {
    const entries = fields
        .filter(isScalarOrEnum)
        .map((f) => `  ${f.name}: ${makeField(f)}`);
    return [
        `export const ${name} = v.object({`,
        entries.join(",\n"),
        "});",
        `export type ${name}Type = v.InferOutput<typeof ${name}>;`,
        "",
    ];
}
function buildSchemasForModel(model, enums) {
    const lines = [];
    lines.push("// Generated by prisma-valibot-generator — Do not edit manually");
    lines.push("import * as v from 'valibot';");
    // Import enum schemas if this model uses any
    const usedEnumNames = getUsedEnumNames(model);
    if (usedEnumNames.length > 0) {
        const importNames = usedEnumNames
            .map((name) => `${name}Picklist`)
            .join(", ");
        lines.push(`import { ${importNames} } from './enums';`);
    }
    lines.push("");
    // Identifier les champs de clés étrangères
    const foreignKeyFields = new Set();
    for (const field of model.fields) {
        if (field.relationFromFields) {
            for (const fkField of field.relationFromFields) {
                foreignKeyFields.add(fkField);
            }
        }
    }
    // Full model (all fields required)
    lines.push(...buildObjectSchema(`${model.name}Schema`, model.fields, (f) => {
        if (!f.isRequired) {
            return `v.nullable(${mapFieldToValibot(f, enums)})`;
        }
        return mapFieldToValibot(f, enums);
    }));
    // Create validator (required fields only — heuristic: required w/o default/id/updatedAt/foreignKeys)
    const createFields = model.fields.filter((f) => isScalarOrEnum(f) &&
        // f.isRequired && //
        !f.hasDefaultValue &&
        !f.isId &&
        !f.isUpdatedAt &&
        !foreignKeyFields.has(f.name));
    lines.push(...buildObjectSchema(`Create${model.name}Schema`, createFields, (f) => {
        if (f.isRequired) {
            return mapFieldToValibot(f, enums);
        }
        return `v.optional(${mapFieldToValibot(f, enums)})`;
    }));
    // Update validator (all fields optional, excluding foreign keys)
    const updateFields = model.fields.filter((f) => !f.isId && !foreignKeyFields.has(f.name));
    lines.push(...buildObjectSchema(`Update${model.name}Schema`, updateFields, (f) => `v.optional(${mapFieldToValibot(f, enums)})`));
    return lines.join("\n");
}
function buildEnumsFile(enums) {
    // Détection automatique : utiliser dbName si au moins un enum a des @map
    const hasAnyMappedValues = enums.some((enm) => enm.values.some((val) => val.dbName !== null && val.dbName !== undefined));
    const pickValue = (val) => {
        var _a;
        if (hasAnyMappedValues) {
            return (_a = val.dbName) !== null && _a !== void 0 ? _a : val.name;
        }
        return val.name;
    };
    const lines = [];
    lines.push("// Generated by prisma-valibot-generator — Do not edit manually");
    lines.push("import * as v from 'valibot';");
    lines.push("");
    for (const enm of enums) {
        // Créer l'enum TypeScript
        const enumValues = enm.values
            .map((val) => {
            const value = pickValue(val);
            return `  ${val.name} = '${value}'`;
        })
            .join(",\n");
        const enumName = `${enm.name}Enum`;
        const picklistName = `${enm.name}Picklist`;
        lines.push(`export enum ${enumName} {`);
        lines.push(enumValues);
        lines.push("}");
        // Créer le schéma Valibot avec v.picklist
        const picklistValues = enm.values
            .map((val) => {
            const value = pickValue(val);
            return `'${value}'`;
        })
            .join(", ");
        lines.push(`export const ${picklistName} = v.picklist([${picklistValues}]);`);
        lines.push(`export type ${enumName}Type = v.InferOutput<typeof ${picklistName}>;`);
        lines.push("");
    }
    return lines.join("\n");
}
async function generateValibot(options) {
    var _a, _b;
    logger_1.default.debug("[prisma-valibot] Starting generation");
    const schemaDir = node_path_1.default.dirname(options.schemaPath);
    const explicitOutput = (_a = options.generator.output) === null || _a === void 0 ? void 0 : _a.value;
    const defaultOutput = node_path_1.default.join(process.cwd(), "node_modules", ".prisma-valibot");
    const outDir = explicitOutput
        ? node_path_1.default.isAbsolute(explicitOutput)
            ? explicitOutput
            : node_path_1.default.join(schemaDir, explicitOutput)
        : defaultOutput;
    const generatedDir = outDir;
    logger_1.default.debug("[prisma-valibot] Output directory resolved to:", generatedDir);
    await node_fs_1.promises.mkdir(generatedDir, { recursive: true });
    await (0, removeDir_1.default)(generatedDir, true);
    logger_1.default.debug("[prisma-valibot] Output directory cleaned");
    const models = options.dmmf.datamodel.models;
    const enums = (_b = options.dmmf.datamodel.enums) !== null && _b !== void 0 ? _b : [];
    // Generate per-model files
    logger_1.default.debug("[prisma-valibot] Generating schemas for models:", models.map((m) => m.name));
    for (const model of models) {
        const content = buildSchemasForModel(model, enums);
        const filePath = node_path_1.default.join(generatedDir, modelFilename(model.name));
        await node_fs_1.promises.writeFile(filePath, content, "utf8");
        logger_1.default.debug(`[prisma-valibot] Wrote schema for model ${model.name} -> ${filePath}`);
    }
    // Generate enums file
    if (enums.length > 0) {
        const enumsContent = buildEnumsFile(enums);
        await node_fs_1.promises.writeFile(node_path_1.default.join(generatedDir, "enums.ts"), enumsContent, "utf8");
        logger_1.default.debug("[prisma-valibot] Wrote enums file");
    }
    logger_1.default.info("Prisma Valibot: generation complete");
}
//# sourceMappingURL=valibot-generator.js.map