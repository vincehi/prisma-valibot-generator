"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateValibot = generateValibot;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const logger_1 = __importDefault(require("./utils/logger"));
const removeDir_1 = __importDefault(require("./utils/removeDir"));
// Minimal Valibot generator per MVP PRD
function mapFieldToValibot(field, enums) {
    // Relations and unsupported treated as any in MVP
    if (field.kind !== 'scalar') {
        return 'v.any()';
    }
    const type = String(field.type);
    switch (type) {
        case 'String':
            return 'v.string()';
        case 'Int':
        case 'Float':
        case 'Decimal':
            return 'v.number()';
        case 'Boolean':
            return 'v.boolean()';
        case 'DateTime':
            return 'v.date()';
        case 'Json':
            return 'v.any()';
        case 'BigInt':
            return 'v.bigint()';
        case 'Bytes':
            return 'v.instance(Uint8Array)';
        default: {
            // Enum or unknown scalar
            const enumDef = enums.find((e) => e.name === type);
            if (enumDef) {
                return `v.union([${enumDef.values
                    .map((v) => `v.literal('${v.name}')`)
                    .join(', ')}])`;
            }
            return 'v.any()';
        }
    }
}
function modelFilename(modelName) {
    return `${modelName}.schema.ts`;
}
function buildSchemasForModel(model, enums) {
    const lines = [];
    lines.push(`// Generated by prisma-valibot-generator — Do not edit manually`);
    lines.push(`import * as v from 'valibot';`);
    lines.push('');
    // Full model (all fields required)
    const fullFields = model.fields.map((f) => {
        const base = mapFieldToValibot(f, enums);
        return `  ${f.name}: ${base}`;
    });
    lines.push(`export const ${model.name}Schema = v.object({`);
    lines.push(fullFields.join(',\n'));
    lines.push(`});`);
    lines.push(`export type ${model.name}SchemaType = v.InferOutput<typeof ${model.name}Schema>;`);
    lines.push('');
    // Create validator (required fields only — heuristic: required w/o default/id/updatedAt)
    const createFields = model.fields
        .filter((f) => f.kind === 'scalar' && f.isRequired && !f.hasDefaultValue && !f.isId && !f.isUpdatedAt)
        .map((f) => `  ${f.name}: ${mapFieldToValibot(f, enums)}`);
    lines.push(`export const Create${model.name}Schema = v.object({`);
    lines.push(createFields.join(',\n'));
    lines.push(`});`);
    lines.push(`export type Create${model.name}SchemaType = v.InferOutput<typeof Create${model.name}Schema>;`);
    lines.push('');
    // Update validator (all fields optional)
    const updateFields = model.fields.map((f) => {
        const inner = mapFieldToValibot(f, enums);
        return `  ${f.name}: v.optional(${inner})`;
    });
    lines.push(`export const Update${model.name}Schema = v.object({`);
    lines.push(updateFields.join(',\n'));
    lines.push(`});`);
    lines.push(`export type Update${model.name}SchemaType = v.InferOutput<typeof Update${model.name}Schema>;`);
    lines.push('');
    return lines.join('\n');
}
async function generateValibot(options) {
    var _a, _b;
    logger_1.default.debug('[prisma-valibot] Starting generation');
    const schemaDir = path_1.default.dirname(options.schemaPath);
    const explicitOutput = (_a = options.generator.output) === null || _a === void 0 ? void 0 : _a.value;
    const defaultOutput = path_1.default.join(process.cwd(), 'node_modules', '.prisma-valibot');
    const outDir = explicitOutput
        ? path_1.default.isAbsolute(explicitOutput)
            ? explicitOutput
            : path_1.default.join(schemaDir, explicitOutput)
        : defaultOutput;
    const generatedDir = outDir;
    logger_1.default.debug('[prisma-valibot] Output directory resolved to:', generatedDir);
    await fs_1.promises.mkdir(generatedDir, { recursive: true });
    await (0, removeDir_1.default)(generatedDir, true);
    logger_1.default.debug('[prisma-valibot] Output directory cleaned');
    const models = options.dmmf.datamodel.models;
    const enums = (_b = options.dmmf.datamodel.enums) !== null && _b !== void 0 ? _b : [];
    // Generate per-model files
    logger_1.default.debug('[prisma-valibot] Generating schemas for models:', models.map(m => m.name));
    for (const model of models) {
        const content = buildSchemasForModel(model, enums);
        const filePath = path_1.default.join(generatedDir, modelFilename(model.name));
        await fs_1.promises.writeFile(filePath, content, 'utf8');
        logger_1.default.debug(`[prisma-valibot] Wrote schema for model ${model.name} -> ${filePath}`);
    }
    // Index barrel
    const indexLines = [];
    for (const model of models) {
        const fileBase = `./${modelFilename(model.name)}`;
        indexLines.push(`export * from '${fileBase.replace(/\\.ts$/, '')}';`);
    }
    await fs_1.promises.writeFile(path_1.default.join(generatedDir, 'index.ts'), indexLines.join('\n') + '\n', 'utf8');
    logger_1.default.debug('[prisma-valibot] Wrote index barrel');
    logger_1.default.info('Prisma Valibot: generation complete');
}
//# sourceMappingURL=valibot-generator.js.map